---
title:  "TIL 12일차"
layout: single
categories:
  - til
tags:
  - 컴퓨터 시스템 2장
  - 코딩테스트
---

# 정보의 표현과 처리

## 정보의 저장
현대 컴퓨터는 두 개의 값을 갖는 신호로 표현되는 정보를 저장하고 처리한다 (비트)

1. 비부호형 인코딩
전통적인 이진수 표시 - 0 이상의 수

2. 2의 보수 인코딩
부호형 정수 표시
- 양수
- 음수

3. 부동소수점 인코딩
소수를 표시하기 위한 방법

- 정수의 표현
비교적 작은 범위의 값을 인코딩 => 매우 정밀

- 부동소수점 표시
넓은 범위의 값을 근사값으로 인코딩

### 메모리
각 바이트는 주소라고 하는 고유한 숫자로 식별 가능

모든 가능한 주소의 집합 => **가상 주소 공간**(이미지에 불과)

- 기계수준의 프로그램
프로그램의 객체를 단순히 바이트들의 블록으로 취급, 프로그램 자신은 바이트의 연속으로 취급

국가표준 연수소의 주도하에 ANSI C 표준이 됨

1. ISO C99 탄생
   1. 영어 언어에 없는 문자를 요구하는 문자 스트링 지원 추가
2. ISO C11 (2011년)
   1. 새로운 데이터 타입과 특징들 추가

> GCC 컴파일 시, 아무 옵션을 명시 하지 않으면 ISO C90에 기초한다.


### 16진수 표시
1바이트 = 8비트 (0 - 255)

|Hex|Decimal|Binary|
|-|-|-|
|1|1|0001|
|2|2|0010|

> 이진수 -> 16진수: 4바이트씩 끊어 읽는다.
> 11/1100/1010/1101/1011/0011: 3CADB3

q(몫), r(나머지)
$x = q * 16 + r$

$x = 26, 1 * 16 + 10 (A)$

### 데이터 크기
모든 컴퓨터는 워드 크기를 규격으로 가짐 -> 포인터의 정규 크기

워드 크기 -> 가상 주소 공간 최대 크기: $2^{64}, 2^{32}$

32비트, 64비트 역방향 호환성을 가지고 있음

> 정수데이터
> 부호형정수: 0, 음수, 양수
> 비부호형정수: 양수값만을 나타냄

- 호환성
여러 가지 데이터 타입의 정확한 크기와 상관없이 동작하게 만드는 것

### 주소 지정과 바이트 순서
1. 객체의 주소가 무엇이 되야하는지
2. 메모리에 바이트들을 어떻게 정렬해야하는지

객체는 연속된 바이트에 저장됨 -> 4바이트 [Ox100, Ox101, Ox102, Ox103]

$x_{w-1},x_{w-2}, ... , x_{1}, x_{0}$: w-비트 정수
$x_{w-1}$: 가장 중요한 비트 / $w_{0}$: 가장 덜 중요한 비트

특정 운영체제가 결정되면 바이트 순서 고정

> 리틀 엔디안
> 객체를 메모리에 가장 덜 중요한 바이트부터 저장

> 빅 엔디안
> 객체를 메모리에 가장 중요한 바이트부터 저장

- 인텔 호환: 리틀 엔디안 방식
- IBM, Oracle 머신들: 빅 엔디안 방식
- 
### 바이트 순서 이슈
1. 이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때
    - 리틀 엔디안 컴퓨터 -> 빅 엔디안 컴퓨터 보낼때, 수신 측 프로그램에서 워드들 내 바이트 순서가 뒤바뀌는 경우
2. 정수 데이터를 나타내는 바이트들을 살펴볼 때

> 네트워크 응용프로그램
> 송신측 -> 컴퓨터가 내부 표시를 네트워크 표준으로 변경
> 수신 측 -> 컴퓨터가 네트워크 표준을 자신의 내부 표시 방식으로 변환

### 스트링의 표시
각 문자는 표준 인코딩에 따라 표시된다.

서로 다른 컴퓨터에서의 인코딩은 호환성이 없는 인스트럭션과 인코딩을 사용한다.

이진 코드는 컴퓨터와 운영체제들의 여러 가지 조합들 간에 호환성을 갖는 경우가 드물다.

UTF-8: 각 문자를 바이트의 연속으로 인코딩하여 / 표준 ASCII 문자들은 ASCII에서 동일한 단일 바이트 인코딩을 사용한다. (동적)

### 부울 대수
- `~` : NOT - P가 참이면 ~P 거짓
- `&` : AND - P가 참 Q가 참이면 참
- `|` : OR - P가 참 Q가 거짓이면 참
- `^` : EXCLUSIVE-OR - P가 참이거나 Q가 참이거나 PQ가 동시에 참이 아닌 경우

부울연산도 곱셈법칙, 분배법칙이 성립한다.

### 비트 벡터 집합 표현 방법
|비트벡터|집합|
|-|-|
|a = [01101001]|A = {0, 3, 5, 6}|
|b = [01010101]|B = {0, 2, 4, 6}|

교집합: A ∩ B = {0, 6}

연산: a&b = [01000001]

### 비트수준 연산
16진수 인자들을 이진수 표시로 확장해서 이진수에서 연산을 실행하고 다시 16진수로 변환하는 것

|C언어 표현|이진수|이진수 결과|16진수|
|-|-|-|-|
|~0x41|0100 0001|1011 1110|0xBE|
|~0x00|0000 0000|1111 1111|0xFF|
|0x69 & 0x55|[0110 1001] & [0101 0101]|0100 0001|0x41|
|0x69 | 0x55|[0110 1001] | [0101 0101]|0111 1101|0x7D|

- a ^ a = 0: 같은 비트끼리 0이됨
```c
int *x; int *y;
// 스왑과정
*y = *x ^ *y // *x = a / *y = a ^ b
*x = *x ^ *y // *x = b / *y = a ^ b
*y = *x ^ *y // *x = b / *y = a
```

마스크 연산: 워드 중에 일부 선택된 비트 집합을 표시

bis - `|`
bic - `R1 & (~R2)`

### c언어 논리연산
|연산자|결과|
|-|-|
|`\|\|`|OR|
|`&&`|AND|
|`!`|NOT|

### 쉬프트 연산자
1. 논리 우측 쉬프트 (부호 상관 x)
   1. 오른쪽에 비트를 민다. 
   2. 왼쪽 빈자리는 0으로 채움
2. 산술 우측 쉬프트
   1. 오른쪽으로 비트를 민다.
   2. 왼쪽자리에 MSB(최상위비트)를 복사

컴파일러/컴퓨터는 산술 우측 쉬프트를 사용함

- 자바 >>: 산술 / >>>: 논리적

덧셈과 뺄셈은 쉬프트연산자보다 우선순위가 높다

## 정수의 표시
1. 양수만 표현할 수 있는 방법
   1. `unsigned`
2. 음수, 0, 양수 모드를 표시할 수 있는 방법

> 0이 비음수이기 때문에 양수의 개수가 음수보다 1적다.
> 
> -128 ~ -1, 0, 1 ~ 127

### 비부호형의 인코딩 (양수)
- $[x_{w-1}, x_{w-2}, .... , x_{0}]$
- w: 비트 수

> 모든 비트의 합
> $$B2U = \vec(x) = \sum_{i=0}^{w-1}x_{i}2^{i}$$
> $B2U_{4}([1011]) = 1 * 2^{3} + 0 * 2^{2} + 1 * 2^{1} + 0 * 2^{0}$

$B2U_{w}$: 전단사의 특징을 갖는다.

- 전단사: 일대일 대응함수

> $UMax = \sum_{i=0}^{w-1}2^{i}$
>
> $UMax_4 = B2U_4([1111]) = 2^4 - 1 = 15$

### 2의 보수 인코딩 (부호형 숫자, 양수, 음수, 0)
- $[x_{w-1}, x_{w-2}, .... , x_{0}]$
- $x_{w-1}$: 부호 비트

> 최상위 비트를 제외한 모든 비트의 합
> $$B2T_{w}\vec(x) = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_{i}2^{i}$$
> $B2T_{4}([1011]) = - 1 * 2^{3} + 0 * 2^{2} + 1 * 2^{1} + 0 * 2^{0}$

$B2T_{w}$: 전단사의 특징을 갖는다

$B2T_{w}의 역함수 = T2B_{w} (2의 보수를 이진수로)$

> $TMin_w = -2^{w-1}$
> 
> $TMin_4 = B2T_4[(1000)] = -8$

> $TMax_w = \sum_{i=0}^{w-2}2^i = 2^{w-1} - 1$
>
> $TMax_4 = B2T_4[(0111)] = 7$

