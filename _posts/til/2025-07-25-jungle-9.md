---
title:  "컴퓨터 시스템 - 프로그램의 기계수준 표현"
layout: single
categories:
  - til
tags:
  - 컴퓨터 시스템 3장
  - cs
---

# 프로그램의 기계수준 표현
```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

```assembler
multstore:
    pushq   %rbx
    movq    %rdi, %rbx        ; 첫 번째 인자를 %rbx에 저장
    call    mult2             ; mult2(rsi, rdx) 수행
    movq    %rax, (%rbx)      ; *rbx = rax (곱한 결과를 저장)
    popq    %rbx
    ret
```

링커의 임무: 이들 함수들을 위한 실행 코드의 위치들과 함수 호출을 일치시키는 것

## 데이터 형식
- 워드: 16비트
- 더블워드: 32비트
- 쿼트워드: 64비트

## 정보 접근하기
%rax : return value
1. %eax: 32비트
2. %ax: 16비트

%rbx : callee saved
1. %ebx: 32비트
2. %bx: 16비트

%rcx : argument 4
1. %ecx: 32비트
2. %cx: 16비트

%rdx : argument 3
1. %edx: 32비트
2. %dx: 16비트

%rsp : stack pointer
1. %esp: 32비트
2. %sp: 16비트

caller-save: 호출된 함수가 마음대로 사용하는 레지스터
callee-save: 호출된 함수가 맨 처음에 들어있던 값을 스택에 저장해두고 사용하다가 다썻다면 복원해야하는 레지스터

caller-save 레지스터: %rax, %rcx, %rdx, %rsi, %rdi, %r8-11
callee-save 레지스터: %rbx, %rbp, %r12-15
​
## 데이터 이동 인스트럭션
1. movb(바이트이동)
2. movw(워드이동)
3. movl(더블워드이동)
4. movq(쿼드워드이동)

## 오퍼랜드 식별자
연산을 수행할 소스값(source) + 그 결과를 저장할 목적지(destination)의 위치를 명시 

> 타입
> immediate: 상수값 = `$`
> register: 레지스터 내용 = 16개의 레지스터를 가리킴
> 메모리참조: 유효주소라고 부르는 계산된 주소에 의해 메모리에 접근

$Imm(r_b, r_i, s)$

## 연산의 그룹
1. 유효주소 적재
2. 단항
3. 이항
4. 쉬프트 이항

## 유효주소 적재
메모리에 접근 하지 않고 계산된 주소만 로드함

## 단항 및 이항 연산
첫 번째 오퍼랜드: 상수, 레지스터, 메모리 위치
두 번째 오퍼랜드: 레지스터, 메모리

## 쉬프트 연산
좌측 쉬프트 연산
- SAL
- SHL

우측 쉬프트 연산
- SHR 논리쉬프트(0으로 채운다)
- SAR 산술 쉬프트(부호 비트를 복사해서 채운다)

## 프로시저
`popq`: 데이터 추출, `pushq`: 데이터를 스택에 추가

P -> Q: 호출 가정

1. 제어권 전달
   1. PC(프로그램 카운터) Q호출 시, Q에 대한 주소로 시작 / 리턴시, P에서 Q를 호출하는 다음 인스트럭션으로 설정
2. 데이터 전달
   1. P는 하나 이상의 매개변수를 Q에게 제공, Q는 다시 P로 하나의 값을 리턴할 수 있어야함
3. 메모리 할당과 반납
   1. Q는 시작할 때 지역변수들을 위한 공간을 할당할 수 있음, 리턴할 때 이 저장소 반납 가능


## 프로시저 호출
프로시저는 최대 6개의 정수값을 레지스터에 저장가능

6개 이상 부터는 P가 Q를 호출 전 스택프레임에 미리 넣어둠 - Argument Build Area

인자 %rdi, %rsi, %rdx, %rcx, %r8, %r9

**스택 1칸당 8바이트(Byte)**



